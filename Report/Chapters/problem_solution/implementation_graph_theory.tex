%!TEX root = ../../Master.tex
\section{Storing A Graph}

This chapter will discuss different methods of storing a graph in memory for a C program to interpret and compute. Furthermore how to read a model of a hospital from a XML document.

\subsection{Sequentially Representation}
A Sequential representation means that the data describing the vertices is placed sequentially in the memory, one vertex after another. The overhead of storing the memory sequentially is very small. Appending a new element to the list is very easy, because the exact location in memory is known. However when inserting an element in the middle of a sequentially list, up to half of the elements need to be moved by 1 position. 



% It can be done by changing what the last element of the list is pointing at, to a new element.
% Removing an item can be done similarly by changing the element pointing to the item that is wanted to be removed, so the list skips a element. This is shown in \cref{fig:examplegraph}.


\subsection{Linked List Representation}
\label{sub:list}
A linked list is defined as \enquote{a list implemented by each item having a link to the next item} \cite{linked_list_def}. This means that every item in the list has a element pointing to the next item in the list. This way of structuring the data makes it possible to dynamic manipulate the list \cite{Linked_List}.  Doing this means that the overhead of storing a linked list is a little bigger than storing a list sequential, because of the next pointers also consume memory. 

Inserting new items to a linked list is relatively easy, compared to sequentially storing memory. This can be done by redirecting a pointer to an element $A$ in the list to a newly created element $B$, and make the the new element point at location where the first element was pointing to $C$. This example is shown at \cref{fig:link}.

\begin{figure}[h]
 \centering
\begin{tikzpicture}[thick,main node/.style={fill=blue!20,draw,font=\sffamily\Large\bfseries}]
  \node[main node] (a) at (0,0) {\(A\)};
  \node[main node] (c) at (4,0) {\(C\)};
  \node[main node] (b) at (2,-2) {\(B\)};
  \node[main node] (d) at (-2,0) {$?$};
  \node[main node] (e) at (6,0) {$?$};
   
   \path[->]
     (d) edge node {$ $} (a)
     (c) edge node {$ $} (e)
     (a) edge [bend right] node {$ $} (b)
     (b) edge [bend right] node {$ $} (c);

  \draw[red,->] (a) to node {\(\not\)} (c);
\end{tikzpicture}
\caption{Linked list example} \label{fig:link}
\end{figure}
 %indsÃ¦t 


% \subsection{data structure}
% In this section it will be covered how a graph actual can be represented in the memory, using the above methods. To explain this there examples in the following sections will be based on the graph shown at \cref{fig:graph}.
% \begin{figure}[h]
% \centering
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,
%   thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\Large\bfseries}]

%   \node[main node] (1) {1};
%   \node[main node] (2) [below left of=1] {2};
%   \node[main node] (3) [below right of=1] {3};
%   \path[-]
%   	(1) edge node {2.0} (3)
%     (2) edge node {1.0} (1)
%     (3) edge node {3.0} (2);
% \end{tikzpicture}
% \caption{example graph} \label{fig:graph}
% \end{figure}




% \begin{figure}[h]
% \centering
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={fill=blue!20,draw,font=\sffamily\Large\bfseries}]

%   \tikzset{mystyle/.style={->,relative=false,in=0,out=0,bend left=100,looseness=3}}

%   \node[main node] at (0,-2) (2) {$V_1$};
%   \node[main node] at (2,-2) (3) {$V_2$};
%   \node[main node] at (4,-2) (4) {$V_3$};
%   \node[main node] at (0,-4) (5) {$EP_1$};
%   \node[main node] at (2,-4) (7) {$EP_2$};
%   \node[main node] at (4,-4) (9) {$EP_1$};
%   \node[main node,label=below:$1$] at (0,-6) (6) {$E_1$};
%   \node[main node,label=below:$1$] at (2,-6) (8) {$E_1$};

%    \path[->]
%    	(2) edge node {VP} (3)
%    	(3) edge node {VP} (4)
%    	(2) edge node {EP} (5)
%    	(5) edge node {EP} (6)
%    	(5) edge node {EP} (7)
%    	(7) edge node {EP} (8)
%    	(6) edge [bend left=60] node { } (2)
%    	(6) edge [bend left=100,looseness=2.3] node { }(3)
%    	(8) edge [bend left=100,looseness=2.5] node { }(2)
%    	(8) edge [bend right=100,label=right] node { }(4);


% \end{tikzpicture}
% \caption{example graph} \label{fig:examplegraph}
% \end{figure}

\subsection{Representing a Graph as XML}

In order to search through a graph in a C program, the graph needs to be read by the C program. XML was chosen as the markup language for representing a graph, because of its readability for both humans and computers. An example of how a graph is represented as XML is seen in \cref{list:xml_demo}.

The XML file has the floors divided into vertices with x and y coordinates. These coordinates are used to calculate the heuristic values, as described in \cref{subs_astar}, of the various vertices. The coordinate can never be a negative value. The coordinates have origo in the lower left corner of a floor.

\lstinputlisting[language=XML, label=list:xml_demo, caption={An example of a graph represented as XML}]{Chapters/problem_solution/demo_xml.xml}

\input{Chapters/problem_solution/data_struct.tex}


