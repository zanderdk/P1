%!TEX root = ../../Master.tex
\begin{minipage}{\linewidth}
\subsection{Implementing the data structure in C}
\label{sub:data_structure}

This subsection will cover how a graph is represented in our C program. The solution was to break the graph into small pieces of information, making it easier to manage the program. It was chosen to split the graph into 5 C structs:


\begin{itemize} [noitemsep]
	\item Graph
	\item Floor
	\item Vertex
	\item Edge Pointer
	\item Edge
\end{itemize}

These structs will be explained in the following sections.
\end{minipage} 

%In \cref{Implementing}, the advantages and disadvantages of a linked list and a array was described.
\begin{minipage}{\linewidth}
\subsection{Graph} 
This is the main struct containing information of one building complex. The struct has a pointer called floors, that points to the first floor struct that contains information about the given floor. All floors are sequentially stored in memory so by incrementing the floors pointer it is possible to access the next floor. How we represent another building is described in \cref{multlayhan}. The element numOfVertices contains how many vertices this graph has in total, and numOfFloors is how many floors this graph has.


\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/graph.c} \label{Graph_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Floor} \label{subsub:floor}
The intention of the floor struct, is to only contain the vertices that are located on the specific floor. The $floorId$ is an identifier that keeps track of which floor it is. $amountOfVertecies$ is a values telling how many vertices this floor has. Vp is a pointer to the first vertex in this floor. All vertices on the same floor are connected using a linked list. This makes it possible to dynamic add new vertices to the floor as described in \cref{sub:list}. The start of the list is pointed to by the floor struct. The ordering of the list of vertices does not matter.

\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/Floor.c} \label{Floor_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Vertex}\label{data_struct:vertex}
A vertex struct stores information about where it is located relative to other vertices using a coordinate set $x$ and $y$. Vertices can be identified using the $vertexId$ and the $floorId$ is used to tell whether two vertices are on the same floor.

 The $type$ can represent:
\begin{itemize}[noitemsep]
	\item \textbf{1}: Normal vertex.
	\item \textbf{2}: Stair vertex.
	\item \textbf{3}: Elevator vertex.
\end{itemize}

$ep$ is a pointer to the first element in a linked list. Each element contains a pointer to the next $Edge pointer$ this vertex is connected to. The benefits of this representations method is described in \cref{sub:list}. It makes it possible to add edges dynamically to a vertex.




\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/vertex.c} \label{vertex_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Edge Pointer}

The edge pointer struct has two elements. One pointing to the $edge$ containing information about the cost of the edge and which vertices it is connected to, and the other element $nextEp$ points to the next edge pointer this Vertex is connected to. When a $nextEp$ is pointing to $NULL$ the end of the list is reached. The edgePointer struct was designed to minimize the instances of edges that needs to be created. Without edgePointers, an instance edge had to be created for every vertex.


\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/ep.c} \label{ep_struct}

\end{minipage}


\begin{minipage}{\linewidth}
\subsection{Edge}
The last struct is the $edge$ struct. An edge struct contains information about which two vertices are connected, using the two $Vertex$ pointers. This allows for a representation of with vertices are connected. The $edgeId$ is used while parsing XML code, to keep track of which vertex is connected to which vertex.

\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/edge.c} \label{edge_struct}
\end{minipage}

\subsection{Summary}
When storing a graph in memory, 5 structs are used. The combination of these structs provides the base representation of a graph in a C program. It is visualized in \cref{fig:examplegraph}.


\begin{figure}[h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={fill=blue!20,draw,font=\sffamily\Large\bfseries}]

  \tikzset{mystyle/.style={->,relative=false,in=0,out=0,bend left=100,looseness=3}}

  \node[main node] at (0,-2) (2) {$V_1$};
  \node[main node] at (2,-2) (3) {$V_2$};
  \node[main node] at (4,-2) (4) {$V_3$};
  \node[main node] at (0,-4) (5) {$EP_1$};
  \node[main node] at (2,-4) (7) {$EP_2$};
  \node[main node,label=below:$1$] at (0,-6) (6) {$E_1$};
  \node[main node,label=below:$1$] at (2,-6) (8) {$E_2$};

   \path[->]
    (2) edge node {VP} (3)
    (3) edge node {VP} (4)
    (2) edge node {EP} (5)
    (5) edge node {EP} (6)
    (5) edge node {EP} (7)
    (7) edge node {EP} (8)
    (6) edge [bend left=60] node { } (2)
    (6) edge [bend left=100,looseness=2.3] node { }(3)
    (8) edge [bend right=30,label=right] node { }(4)
    (8) edge [bend right=100,looseness=3] node { }(2);
\end{tikzpicture}
\caption{Visual representation of how a graph is implemented in C} \label{fig:examplegraph}
\end{figure}

