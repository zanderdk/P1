%!TEX root = ../../Master.tex

\subsection{Data Structure}
\label{sub:data_structure}

This subsection will cover which way of representing a graph that has been chosen. The solution was to break the graph in to small pieces of information, this made it easier to keep track of the program. It was chosen to split the datasets in to 5 structs.
\begin{minipage}{\linewidth}
\begin{itemize} [noitemsep]
	\item Graph
	\item Floor
	\item Vertex
	\item Edge Pointer
	\item Edge
\end{itemize}
\end{minipage}

These structs will be explained in the following sections. 

%In \cref{Implementing}, the advantages and disadvantages of a linked list and a array was described.
\begin{minipage}{\linewidth}
\subsection{Graph} 
This is the main struct containing information of one building complex.
The struct have a pointer called floors that points to the first floor struct that contains information about one floor. All floors is sequentially stored in the memory so by incrementing the pointer it is possible to access the next element. How we represent another building is described in \cref{multlayhan}. The element numOfVertices contains how many vertices this graph have in total, and numOfFloors is how many floors this graph have.


\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/graph.c} \label{Graph_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Floor} \label{subsub:floor}
This struct reasonably simple the functionality of it, is to separate vertices so a floor only contains a vertices that is located a the same floor. The $floorId$ is an identifier to keep track of which floor that are in use.
$amountOfVertecies$ is a values telling how many vertices this floor have. Vp is a pointer to the first vertex in this floor.

\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/Floor.c} \label{Floor_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Vertex}\label{data_struct:vertex}
A vertex struct holds information about where it is located relative to other vertices using a coordinate set $x$ and $y$. Vertices can be identified using the $vertexId$, the $floorId$ is used to tell whether to vertices is at the same layer.

 The $type$ can represent:
\begin{itemize}[noitemsep]
	\item \textbf{1}: Normal vertex.
	\item \textbf{2}: Stair vertex.
	\item \textbf{3}: Elevator vertex.
\end{itemize}

The $ep$ is a pointer to the first element in a linked list row, each element is contains a pointer to the next $Edge pointer$ that this vertex is connected to. The benefits of this representations method is described in \cref{sub:list} and makes it possible to add edges to this vertex after initialization.


All vertecies on in the same floor is connected using a linked list. This makes it possible to dynamic add new vertices to the floor as described in \cref{sub:list}. The start of the list is pointed to by the floor struct. It is important to mention that the order of the list plays no role.   


\lstinputlisting[language=C, frame=single, numbers=left]{Chapters/problem_solution/vertex.c} \label{vertex_struct}
\end{minipage}

\begin{minipage}{\linewidth}
\subsection{Edge Pointer}

The edge pointer struct have two elements one pointing to the $edge$ containing information about the cost of the edge and which vertices it is connected to. And the other element $nextEp$ points to the next edge pointer this Vertex is connected to. When a $nextEp$ is pointing to $NULL$ the end of the list is reached.
\lstinputlisting[language=C, frame=single, numbers=left]{Chapters/problem_solution/ep.c} \label{ep_struct}

\end{minipage}



\begin{minipage}{\linewidth}
\subsection{Edge}
The last struct is the $edge$ struct, this struct is pointed to by two vertices using a $edge$ pointer. The same to vertices is pointed to by the $edge$, using the two $Vertex$ pointers. This represent with vertices is connected.
The $edgeId$ used while parsing XML code, to keep track of which vertex is connected to which vertex.
This is is done because a pointer to an edge cant be stored in files, so ids is used to represent a pointer. 
\lstinputlisting[style=customc, language=C, frame=single, numbers=left]{Chapters/problem_solution/edge.c} \label{edge_struct}
\end{minipage}


\subsection{Summary of Graph Theory}


The sequentially representation requires less memory, and adding or removing elements is also easier compared to a linked list representation, which have meant that the sequentially representation have been chosen for representing a graph 


\begin{figure}[h]
\centering
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3cm,thick,main node/.style={fill=blue!20,draw,font=\sffamily\Large\bfseries}]

  \tikzset{mystyle/.style={->,relative=false,in=0,out=0,bend left=100,looseness=3}}

  \node[main node] at (0,-2) (2) {$V_1$};
  \node[main node] at (2,-2) (3) {$V_2$};
  \node[main node] at (4,-2) (4) {$V_3$};
  \node[main node] at (0,-4) (5) {$EP_1$};
  \node[main node] at (2,-4) (7) {$EP_2$};
  \node[main node,label=below:$1$] at (0,-6) (6) {$E_1$};
  \node[main node,label=below:$1$] at (2,-6) (8) {$E_2$};

   \path[->]
   	(2) edge node {VP} (3)
   	(3) edge node {VP} (4)
   	(2) edge node {EP} (5)
   	(5) edge node {EP} (6)
   	(5) edge node {EP} (7)
   	(7) edge node {EP} (8)
   	(6) edge [bend left=60] node { } (2)
   	(6) edge [bend left=100,looseness=2.3] node { }(3)
   	(8) edge [bend right=30,label=right] node { }(4)
   	(8) edge [bend right=100,looseness=3] node { }(2);


\end{tikzpicture}
\caption{example graph} \label{fig:examplegraph}
\end{figure}
